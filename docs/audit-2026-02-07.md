# Deep Codebase Audit -- 7 February 2026

Comprehensive audit across security, backend logic, frontend state management, performance, and test coverage.

## Fixes Applied (7 Feb 2026)

### Critical (all 5 fixed)
- [x] #1 PRAGMA foreign_keys = ON -- middleware added to worker.js
- [x] #2 IDOR cross-org user modification -- org_id filter added to PUT /api/users/:id
- [x] #3 Global books editable by any teacher -- org_book_selections check on PUT, DELETE removes org link only
- [x] #4 Data export no auth -- blocked in multi-tenant mode
- [x] #5 Token refresh race condition -- shared promise pattern, authTokenRef for stale closure fix (#12)

### High (9 fixed)
- [x] #8 Password reset tokens not invalidated -- old tokens revoked before new creation
- [x] #9 Book search/pagination bypasses org scoping -- INNER JOIN org_book_selections in all paths
- [x] #10 hasApiKey always returns false -- fixed SELECT to include has_key column
- [x] #11 rowToStudent crashes on malformed JSON -- safeJsonParse with try/catch
- [x] #12 Stale closure fetchWithAuth -- authTokenRef (fixed with #5)
- [x] #13 Org deletion doesn't invalidate sessions -- batch deactivate users + revoke refresh tokens
- [x] #14 Missing input validation on reading sessions -- server-side validation added
- [x] #15 Email template HTML injection -- escapeHtml() applied to all user-controlled values
- [x] #16 Login timing attack -- dummy hashPassword() for non-existent users

### High (also fixed)
- [x] #17 Optimistic update rollbacks -- functional state updates in addStudent, updateStudent, deleteStudent, updateStudentClassId, bulkImportStudents
- [x] #18 bulkImportStudents unbounded parallel -- batches of 5

### Performance Quick Wins (4 fixed)
- [x] P6 Composite indexes -- migration 0020 adds idx_students_org_active, idx_sessions_student_date, idx_org_books_org_available, idx_users_org_active
- [x] P4 Batch import confirm -- collected statements executed via db.batch() in chunks of 100 instead of sequential per-item queries
- [x] P7 Batch organization stats -- 6 sequential COUNT queries consolidated into single db.batch() call
- [x] P5 Default book list cap -- GET /api/books without pagination now capped at 5,000 rows with is_available filter

### Tests Added (93 new tests)
- security-audit.test.js (50 tests): error handler sanitization, createError helpers, encrypt/decrypt round-trip, parseCookies edge cases, CSV column detection, prototype pollution
- auth.test.js (43 tests): login lockout, deactivated user/org rejection, token refresh rotation, duplicate email registration, password reset full flow

---

## CRITICAL: Must Fix (RESOLVED)

### 1. Foreign Keys Are Never Enforced (Data Integrity)
**Impact**: Every `FOREIGN KEY` and `ON DELETE CASCADE` in every migration is decorative.

SQLite/D1 requires `PRAGMA foreign_keys = ON` per connection. This pragma is never executed anywhere in the codebase. This means:
- Deleting an organization does NOT cascade to students, classes, or sessions
- Deleting a student does NOT cascade to reading sessions or preferences
- Deleting a book does NOT clean up `org_book_selections` or `students.current_book_id`
- Orphaned records will accumulate silently

**Fix**: Execute `PRAGMA foreign_keys = ON` at the start of every request, or add explicit cleanup queries in delete handlers.

### 2. IDOR: Cross-Org User Modification (`users.js:288`)
The `PUT /api/users/:id` endpoint fetches the target user by ID **without** filtering by organization:
```sql
SELECT * FROM users WHERE id = ?  -- No organization_id filter!
```
An admin in Org A can update (change role, deactivate) a user in Org B by guessing their UUID.

**Fix**: Add `AND organization_id = ?` to the user lookup query for non-owner roles.

### 3. Global Books Editable by Any Teacher (`books.js:440-480`)
`PUT /api/books/:id` and `DELETE /api/books/:id` modify the **global** books table. Since books are shared across organizations, a teacher in Org A can modify or delete a book that Org B depends on. The import confirm endpoint (`books.js:733`) also allows updating global book records.

**Fix**: Either check `org_book_selections` membership before allowing modification, or only allow org-scoped operations.

### 4. Data Export Endpoint Has No Auth/Tenant Scoping (`data.js:20-83`)
`GET /api/data` exports ALL KV data. `POST /api/data` replaces ALL KV data. Neither has role checks or organization scoping. Any authenticated user (even readonly) can dump or overwrite the entire datastore.

**Fix**: Disable in multi-tenant mode, or add `requireOwner()` middleware.

### 5. Token Refresh Race Condition -- Concurrent Callers Rejected (`AppContext.js:191`)
When `refreshingToken.current` is `true`, concurrent callers get `null`, which `fetchWithAuth` interprets as "session expired" and throws an error. If 3 API calls trigger refresh simultaneously, only 1 succeeds; the other 2 fail and potentially log the user out.

**Fix**: Return a shared promise from the first refresh call; concurrent callers await the same promise.

---

## HIGH: Should Fix Soon

### 6. Rate Limiter TOCTOU Race Condition (`tenant.js:314-338`)
The rate limiter does SELECT count, check, INSERT -- three separate non-atomic steps. Concurrent requests can all pass the check before any INSERT completes, making brute-force protection ineffective.

**Fix**: Use D1 batch or Cloudflare's built-in Rate Limiting Rules.

### 7. Book Import Creates Duplicates Under Concurrency (`books.js:578-759`)
The preview-then-confirm flow has no protection against concurrent imports. Two users importing the same CSV will both classify the same titles as "new" and create duplicates. No unique constraint on `(title, author)` prevents this.

**Fix**: Add a unique constraint or use INSERT ... ON CONFLICT.

### 8. Password Reset Tokens Not Invalidated (`auth.js:647`)
Requesting multiple resets creates multiple valid tokens. Old tokens are never revoked. An attacker who compromises an email has a wider attack window.

**Fix**: `UPDATE password_reset_tokens SET used_at = datetime('now') WHERE user_id = ? AND used_at IS NULL` before inserting new tokens.

### 9. Book Search/Pagination Bypasses Org Scoping
- `GET /api/books/search` via `searchBooks()` queries the global `books` table, not `org_book_selections` (`d1Provider.js:365`)
- `GET /api/books?page=1` via `getBooksPaginated()` queries global books (`books.js:49-54`)
- `GET /api/books/library-search` never joins `org_book_selections` (`books.js:130`)

Any of these return books from organizations the user shouldn't see.

**Fix**: Join with `org_book_selections` in all book query paths.

### 10. `hasApiKey` Always Returns False (`organization.js:290-298`)
The SELECT query for AI config does not include `api_key_encrypted` in its column list, so `config.api_key_encrypted` is always `undefined`, and the UI always shows "no API key configured."

**Fix**: Add `api_key_encrypted` to the SELECT column list (or just `api_key_encrypted IS NOT NULL as has_key`).

### 11. `rowToStudent` Crashes on Malformed JSON (`students.js:50-51`)
```js
likes: row.likes ? JSON.parse(row.likes) : []
```
If any student has corrupted `likes`/`dislikes` JSON, `JSON.parse` throws an unhandled exception that crashes the entire `GET /api/students` endpoint for all students in the organization.

**Fix**: Wrap in try/catch, defaulting to `[]`.

### 12. Stale Closure: `fetchWithAuth` Captures Old `authToken` (`AppContext.js:254`)
After a token refresh, `fetchWithAuth` still holds the pre-refresh token in its closure until React re-renders. Any call during the same render cycle uses the stale expired token, triggering another refresh attempt.

**Fix**: Store the token in a ref and read it at call time, not at closure creation time.

### 13. Organization Deletion Doesn't Invalidate Sessions (`organization.js:655-680`)
Soft-deleting an org sets `is_active = 0` but doesn't deactivate users, revoke refresh tokens (7-day lifetime), or deactivate child entities. Users can continue operating for up to 15 minutes (access token TTL) and potentially refresh for 7 days.

**Fix**: Revoke all refresh tokens for org users, and set all org users to `is_active = 0`.

### 14. Missing Input Validation on Reading Sessions (`students.js:830-843`)
Session creation accepts arbitrary values with no validation:
- `pagesRead` / `duration` can be negative, huge, or non-numeric
- `date` is not validated as a proper date format
- `notes` has no length limit
- `assessment` / `location` accept arbitrary strings

**Fix**: Validate all fields server-side before insertion.

### 15. Email Template HTML Injection (`email.js:51, 222`)
User-controlled values (`recipientName`, `organizationName`, `temporaryPassword`) are interpolated into HTML email templates without escaping. A malicious name could inject HTML for phishing.

**Fix**: Create and apply an `escapeHtml()` utility.

### 16. Login Timing Attack Enables Email Enumeration (`auth.js:311-330`)
Non-existent users return immediately. Existing users with wrong passwords go through PBKDF2 (100k iterations). The measurable timing difference reveals which emails have accounts.

**Fix**: Perform a dummy PBKDF2 hash for non-existent users.

### 17. Optimistic Update Rollbacks Overwrite Concurrent Changes (`AppContext.js:746+`)
Every optimistic update captures `previousStudents = students` from the closure. If two rapid updates occur, the second's rollback snapshot doesn't include the first's optimistic change. A failed second update erases the first.

**Fix**: Use functional state updates for rollbacks: `setStudents(prev => /* recalculate from prev */)`.

### 18. `bulkImportStudents` Fires Unbounded Parallel Requests (`AppContext.js:798`)
`Promise.all` fires one HTTP request per student with no concurrency limit. A class of 30+ students creates 30+ simultaneous requests.

**Fix**: Use a concurrency pool (e.g., batches of 5).

---

## MEDIUM: Should Plan To Fix

### 19. Streak Semantics: Counts Dates, Not Consecutive Days (`streakCalculator.js:97-117`)
With grace period of 1, reading Mon + Wed = streak of 2 (gap is 2 days = gracePeriodDays + 1). A student reading every other day accumulates an ever-increasing "streak." May be intentional but is semantically misleading.

### 20. `daysBetween` DST Fragility (`streakCalculator.js:47-52`)
Uses `Math.floor(diffTime / 86400000)` which can lose a day during spring-forward DST if the runtime interprets date-only strings as local time.

### 21. `normalizeString` Strips Non-Latin Characters (`stringMatching.js:12-19`)
`/[^\w\s]/g` only keeps `[a-zA-Z0-9_]`. Books with CJK, Arabic, or accented titles normalize to empty strings, causing all such books to false-positive match as duplicates during import.

### 22. CSV Parser Breaks on Newlines in Quoted Fields (`csvParser.js`)
The parser splits on `\n` before handling quotes. A CSV field like `"Line1\nLine2"` splits incorrectly, breaking the row structure.

### 23. No Double-Submit Protection on HomeReadingRegister (`HomeReadingRegister.js:514`)
`handleRecordReading` has no guard against being called while already in progress. No `disabled` prop on buttons during submission. Fast double-click creates duplicate sessions.

### 24. `switchOrganization` Uses Stale `fetchWithAuth` (`AppContext.js:658-679`)
`setActiveOrganizationId(orgId)` followed by `reloadDataFromServer()` in the same synchronous block. The `fetchWithAuth` in the closure still has the old org ID, so data may be fetched for the wrong organization.

### 25. BookImportWizard `isLoading` Not Reset on Close (`BookImportWizard.js:154`)
Closing the dialog during a request-in-flight leaves `isLoading = true`. Reopening shows a progress bar with no actual operation.

### 26. Class Deletion Unassigns Inactive Students (`classes.js:331-334`)
`UPDATE students SET class_id = NULL WHERE class_id = ?` hits all students including soft-deleted ones. If later restored, they lose their class assignment.

### 27. Duplicate Session Creation (`students.js:804-877`)
No uniqueness check on student + date + book. Concurrent requests (e.g., from Home Reading Register) can create duplicate sessions.

### 28. Reading Level Comparison Uses String `!==` (`books.js:625-627`)
Import preview flags `"3.0"` vs `"3"` as a conflict even though they're the same level.

### 29. CAST() Prevents Index Usage (`books.js:144-147`)
```sql
CAST(b.reading_level AS REAL) >= ? AND CAST(b.reading_level AS REAL) <= ?
```
The function wrapper on the column prevents SQLite from using `idx_books_reading_level`.

### 30. `ReadingLevelRangeInput` No Range Clamping (`ReadingLevelRangeInput.js:13-20`)
HTML `min`/`max` attributes don't prevent manual entry of out-of-range values. A user can type `0.5` or `99.9` and it propagates immediately.

### 31. `BookManager` Export Uses `data:` URI (`BookManager.js:329`)
For 18,000+ books, `data:` URIs can exceed browser limits. Should use `Blob` + `URL.createObjectURL` (which `AppContext.exportToJson` already does correctly).

### 32. Duplicate Settings Endpoints (`settings.js` vs `organization.js`)
Both have settings update logic with different `allowedKeys` lists, creating confusion about which endpoint to use.

### 33. `longestStreak` Never Decreases (`students.js:315`)
`Math.max(streakData.longestStreak, student.longestStreak)` means deleting sessions that were part of the longest streak never reduces it.

---

## PERFORMANCE: Bottlenecks

### P1. CRITICAL: Cron Streak Recalculation is O(orgs * students * 4 queries)
`recalculateAllStreaks` does 4 queries per student (fetch sessions, grace period, timezone, update). Grace period and timezone are re-fetched per student even though they're org-level values. 200 students = 800 queries per org.

**Fix**: Fetch org settings once per org. Batch-fetch all sessions per org in one query. Batch-update streaks.

### P2. CRITICAL: `GET /api/students` Returns Full Session History
All sessions for all students loaded into memory and returned as JSON. 200 students x 100 sessions = 20,000 rows, potentially 5-10MB response.

**Fix**: Return summary stats only from list endpoint. Fetch sessions on-demand per student.

### P3. HIGH: Import Preview Loads ALL 18,000 Books Into Memory
`SELECT * FROM books` + O(n*m) fuzzy matching. 500 imported vs 18,000 existing = 18 million string comparisons.

**Fix**: Do dedup in SQL (exact match), only load candidates for fuzzy matching.

### P4. HIGH: Import Confirm Does Sequential Per-Item Queries
~1,200 sequential queries for 750 books instead of using `db.batch()`.

**Fix**: Group operations into 100-statement batch chunks.

### P5. HIGH: `GET /api/books` Returns All Org Books With No Pagination
18,000 books serialized as JSON in one response (10-30MB).

**Fix**: Always paginate.

### P6. HIGH: Missing Composite Index `students(organization_id, is_active)`
Every student query filters on both columns. Individual indexes exist but no composite. SQLite uses only one index per scan.

### P7. MEDIUM: Organization Stats Uses 6 Sequential Queries
Could be combined into a single query or run via `db.batch()`.

### P8. MEDIUM: No Concurrency Limit on OpenLibrary Cover Fetches
50 unique books rendering simultaneously fires 50 HTTP requests. OpenLibrary rate limit is ~100/5min. Failed lookups are not cached, causing retry storms.

### P9. MEDIUM: `ORDER BY RANDOM()` on 18k Books
Full table scan and sort on every AI recommendation request.

### P10. LOW: localStorage Cache Written on Every Single Cover Fetch
`JSON.stringify()` + `localStorage.setItem()` of potentially thousands of entries on every new cover load.

---

## TEST GAPS: Priority Tests to Add

### Tier 1: Critical Security (no tests exist for auth routes)

**1. Auth Login: Account lockout after failed attempts**
- Tests the lockout mechanism (5 fails -> 429, success after cooldown)
- Would catch: broken brute-force protection

**2. Auth Token Refresh: Rotation and old token revocation**
- Use refresh token, verify old one is revoked, verify new one works
- Would catch: perpetual access from stolen tokens

**3. Auth Registration: Duplicate email rejection**
- Verify 409 for existing email, verify batch org+user creation
- Would catch: duplicate account data integrity issues

**4. Auth Password Reset: Full flow with expiry**
- Forgot -> reset -> verify token used -> verify old tokens fail
- Would catch: broken password reset locking users out

**5. Auth Login: Deactivated user and inactive org rejection**
- Verify 403 for `is_active=0` users and orgs
- Would catch: fired employees retaining access

### Tier 2: Infrastructure & Safety

**6. AI Service: Provider error handling and response parsing**
- Mock 401, malformed JSON, Gemini safety block, normalize edge cases
- Would catch: cryptic 500 errors for users

**7. Encrypt/Decrypt Round-Trip**
- Encrypt then decrypt, wrong key, legacy unencrypted data
- Would catch: broken AI features from bad decryption

**8. Rate Limiting: Request counting and 429**
- Simulate 5 requests, verify 6th returns 429
- Would catch: disabled brute-force protection

**9. Error Handler: 5xx Sanitization**
- Verify 5xx errors return "Internal Server Error", 4xx pass through
- Would catch: regression of security fix (commit 2580f4c)

**10. Tenant Middleware: Owner org override via X-Organization-Id**
- Owner gets switched org, admin gets ignored, invalid org gets 404
- Would catch: broken multi-school management or data breach

### Tier 3: Business Logic Edge Cases

**11. Streak Calculator: Non-UTC timezone handling**
- Sessions in Pacific/Auckland, America/New_York, invalid timezone fallback
- Would catch: wrong-day streak counts for non-UTC schools

**12. CSV Parser: Empty input and newlines in quoted fields**
- Empty CSV throws, newlines in quotes handled correctly
- Would catch: import failures from Excel-exported CSVs

**13. String Matching: isFuzzyMatch author containment**
- "Tolkien" matches "J.R.R. Tolkien", empty authors, custom threshold
- Would catch: duplicate books flooding school libraries

**14. Reading Session: Invalid date format handling**
- Session with date "not-a-date" -- document/fix the gap
- Would catch: streak calculation corruption

**15. Book Import: D1 batch 100-statement limit**
- Import 150 books, verify batch is split correctly
- Would catch: silent import failures at scale

### Tier 4: Frontend Robustness

**16. Token refresh: concurrent callers await shared promise**
- Three simultaneous fetchWithAuth calls all needing refresh
- Would catch: spurious "session expired" errors

**17. Settings: Prototype pollution via `__proto__` keys**
- Send forbidden keys in settings body, verify they're dropped
- Would catch: prototype pollution attacks

**18. parseCookies: Edge cases**
- Multiple cookies, `=` in values, empty/null header
- Would catch: broken session refresh

**19. Error Handler Helpers: createError, notFoundError, badRequestError**
- Verify correct status codes and message shapes
- Would catch: malformed error responses

**20. CSV Column Detection: Ambiguous headers**
- Headers like "by" matching "Published by", "name" matching "Author Name"
- Would catch: wrong column mapping on import
